## 块作用域
ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。
而ES6可以。
ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。
对于ES6环境的浏览器，块级作用域函数生命力的行为类似于var，其余仍类似let

  **应当避免在块作用域中声明函数，应该写成函数表达式**

```javascript 
let f = function () {}
```
### let

1. for循环 ()内和{}内是两个作用域
2. 暂时性死区：
   let变量会“绑定”这个所在块级作用域，不再受外部影响
   ```javascript
   var tmp = 123;
   if (true) {
     tmp = 'abc'; // ReferenceError
     let tmp;
   }
   ```
总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。

3. let不存在变量提升
### const
值得提的就是const实质是变量内存指向的的内存不能改变数据。对于简单类型，相当于常量，对于引用类型，只能保证地址不改变，而例如对象的属性是可以改变的。
const和let一样，只在块作用域内有效，存在暂时性死区，变量声明不提升

const声明的常量，也与let一样不可重复声明。

  **let const class声明的变量，不再等同于顶层对象的属性**
<!-- more -->
## 变量的解构赋值
ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。
例如let [a, b, c] = [1, 2, 3];

但是等号右边必须是可遍历的，具备Iterator接口的

```javascript
let [foo] = 1;
let [foo] = false;
let [foo] = NaN;
let [foo] = undefined;
let [foo] = null;//以上转换为对象之后不具备Iterator接口
let [foo] = {};//本身不具备Iterator接口
// 以上都会报错
```

如果解构不成功，值就为undefined。右边的值比左边的多，也是可以成功的，成为不完全解构。
  ### 对象的解构
  本质是：let { foo: foo, bar: bar } = { foo: 'aaa', bar: 'bbb' };
  先找到同名属性，然后赋值给对应变量，真正被赋值的是后者
  也就是 属性名:变量名。属性名永远是模式，不会被赋值。
  是浅拷贝

  对象解构是可以使用默认值的，只有严格等于（===）undefined的时候，默认值才会生效。(null==undefined为true)

```javascript
  var {x = 3} = {x: undefined};
  x // 3
  var {x = 3} = {x: null};
  x // null
```

  **几个注意点：**
  1. {x}={x:1}需要放在()中，如果打头写会被当作代码块。会报错
  2. 解构赋值允许等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。比如({}=[])之类
  3. 由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。
  ```javascript
  let arr = [1, 2, 3];
  let {0 : first, [arr.length - 1] : last} = arr;
  first // 1
  last // 3
  ```
  上面代码对数组进行对象解构。数组arr的0键对应的值是1，[arr.length - 1]就是2键，对应的值是3。方括号这种写法，属于“属性名表达式”（参见《对象的扩展》一章）。

  ### 字符串的解构
  字符串会被转换成类似数组的对象，是具有length属性的，这个length属性也可以解构赋值。
  ```javascript
  let {length : len} = 'hello';//len=5
  ```
  ### 数值和布尔值的解构
 会被转换成对象。
  ### 函数参数解构赋值

 可以使用默认值

  ```javascript
  function add([x, y]){
    return x + y;
  }
  add([1, 2]); // 3
  ```
  传入参数时被拆分为x和y，而不是一个数组

### 解构赋值的规则

只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。

  ### 圆括号问题
  解构赋值解析起来并不容易，建议尽量不要在*模式*中放置与圆括号
  这里的模式仅仅指模式，就是 模式：变量 的模式
  可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。
## 数组扩展
  ... 将一个数组转为用逗号分割的的参数序列
  应用：
1. 复制数组
```javascript
const a1 = [1, 2]
// 写法一
const a2 = [...a1]
// 写法二
const [...a2] = a1
```
2. 合并数组
```javascript
[...arr1, ...arr2, ...arr3]
```
3. 与解构赋值结合
如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。
4. 字符串相关
可以直接将字符串转为真正的数组
5. 实现了Iterator接口的对象
6. Map 和 Set 结构，Generator 函数
## 对象扩展
  ...将对象中的属性提取
  属性和方法名可以简写
  字面定义对象可以使用[]来定义属性，即把表达式放在方括号内
  但是上述两者不能同时使用
  注意，表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]
  ##对象的解构赋值与扩展运算符

`let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };//z={a:3,b:4}`
    扩展运算符的解构赋值只能是最后一个参数，要求等号右边是一个对象
    对象的解构赋值是浅拷贝
    另外，扩展运算符的解构赋值，不能复制继承自原型对象的属性。

`let { ...o3 } = o2;//o3只会赋值o2自身的属性`
    对象的扩展运算符：
     用于取出所有的可遍历属性，如果扩展运算符后面是一个空对象，则没有任何效果，如果不是对象，则会
     自动将其转换为对象。true，undefine，null之类的会返回一个空对象。字符串会自动转成一个类似数组的对象{0:"h",1:"z",2:"q"}
     可以用来合并对象
     用户自定义的属性放在扩展运算符后面会覆盖，而如果自定义属性放在扩展运算符前面，就变成了设置新对象的默认属性值（总而言之还是后定义的会覆盖前面的。
     对象的扩展运算符后面可以跟表达式。
     扩展运算符的参数对象之中，如果有取值函数get，这个函数是会执行的
#对象的新增方法
  1.is(a,b) 和===行为基本一致，只有两个区别：一是+0不等于-0，二是NaN等于自身。
  2.Object.assign(target, source1, source2);用于合并对象
    注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。
    只有一个参数，会返回这个参数，如果该参数不是对象，则会先转成对象，然后返回
    undefined和null出现在首参数(目标对象)，由于不能转成对象，会报错。如果是源对象的位置，如果不能转成对象就会跳过，所以不会报错。
      布尔值、数值、字符串分别转成对应的包装对象，可以看到它们的原始值都在包装对象的内部属性[[ PrimitiveValue]]上面，这个属性是不会被Object.assign拷贝的。
      只有*字符串*的包装对象，会产生可枚举的实义属性，那些属性则会被拷贝。
      Object.assign拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）。
    Object.assign可以用来处理数组，但是会把数组视为对象。
      Object.assign([1, 2, 3], [4, 5])
      // [4, 5, 3]
    Object.assign只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制。
#函数扩展
 ##函数参数默认值
  参数默认值是惰性计算的，每次都会重新计算表达式的值
  直接写在参数定义的后边，参数列表尾部的参数使用默认值才有意义，可以看出到底可以省略哪些参数，
  如果不是尾参数设置默认值，实际上这个参数是不能被省略的（因为传参是从左到右传的），除非显式输入undefined，将触发该参数等于默认值，而null没有这个效果

  可以将参数默认值设为undefined，表明这个参数是可以省略的。
 ##函数参数与解构赋值配合
  参数是个对象（数组？？）可以双重默认值
 ##函数的length属性
  函数的length属性，将返回没有指定默认值的参数个数。
  leng属性的含义：该函数预期传入的参数个数，指定默认值之后就不包括该参数了。
  length属性不包括rest参数
 ##设置默认值，参数会形成一个单独的作用域

```var x = 1;
  function f(x, y = x) {
    console.log(y);
  }
  f(2) // 2
```

如果参数的默认值是一个函数，该函数的作用域也遵守这个规则。请看下面的例子。
 ##rest参数
  形如...arg，用来接收多余的参数。
  rest参数是一个数组，而arguments对象是一个类似数组的对象。
  rest参数只能最后一个参数，否则会报错。
 ##箭头函数
  如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。
  var sum = (num1, num2) => { return num1 + num2; }
  由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。
  ！注意：在箭头函数中，this指向是固定的，就是定义生效时所在的对象。
  因此会有不适用的地方：
  1.定义对象的方法中的this
  2.需要动态this的时候，例如监听函数

## Class
方法之间不需要加逗号，加了会报错。
类的的数据类型其实就是函数，类本身就指向构造函数，可以直接对类使用new命令
Point === Point.prototype.constructor // true
在类的实例上面调用方法，其实就是调用原型上的方法,事实上,类的所有方法都定义在类的prototype属性上面。
类内部定义的方法不可枚举,这和ES5行为不一致。
constructor函数必须有，没有会默认添加一个空函数。
类必须使用new调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行
实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。可用hasOwnProperty方法检测
##取值函数（getter）和存值函数（setter)
与 ES5 一样，在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。
存值函数和取值函数是设置在属性的 Descriptor对象上的。

类的属性名，可以用表达式。
和函数一样，类的定义也可以用表达式的形式。 规则也和函数类似，函数名只在class内部有用，也可以省去（类似匿名函数）。
同样，加个括号就是立即执行类。

**类不存在变量提升。**

**this的问题：**
class中this默认指向实例，但如果把方法保存起来单独使用就会指向undefined（class内部是严格模式）
解决方法：

1. 在构造方法中绑定this

`this.printName = this.printName.bind(this)`

2. 箭头函数
3. proxy

### 静态方法

方法前加上static关键字，表示该方法不会被实例继承，而是直接通过类来调用(Foo.method())。称为静态方法
静态方法的this指的是类而不是实例。
父类的静态方法可以被子类继承，静态方法也可以从super对象上调用。
### 实例属性新写法
实例属性除了定义在constructor()方法里面的this上面，也可以定义在类的最顶层，不需要写类型，看上去也一目了然。
### 静态属性
指class本身的属性，而不是定义在实例对象（this）上的属性。
写法就是Class.prop=
还有一个提案是在实例属性前面加上static关键字。

## 节流与防抖

节流：
```let throttle = function(func, delay) {
let timer = null
return ()=> {
  if (!timer) {
    timer = setTimeout(function() {
      func.apply(this, arguments)
      timer = null
    }, delay)
		}
	}
}
function handle() {
	console.log(Math.random())
}
window.addEventListener("scroll", throttle(handle, 1000)) //事件处理函数
```

防抖

```function debounce(fn, wait) {
var timeout = null
return function() {
	if (timeout !== null) clearTimeout(timeout)//如果多次触发将上次记录延迟清除掉
      timeout = setTimeout(()=> {
          fn.apply(this, arguments);
          timeout = null;
        }, wait);
    }
  }
  // 处理函数
  function handle() {
    console.log(Math.random());
  }
  // 滚动事件
  window.addEventListener("scroll", debounce(handle, 1000));
```


